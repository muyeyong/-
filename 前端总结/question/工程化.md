## 常用的loader 和 plugin

css-loader

less-loader

sass-loader

babel-loader

ts-loader

file-loader



html-webpack-plugin

## webpack loader 与 plugin区别

loader是用来处理文件解析的，plugin可以监听webapck整个打包的过程，可以实现loader不能实现的功能，比如说压缩代码、分割代码

## 怎样实现一个loader 和 plugin

~~loader需要提供一个apply方法~~,loader就是一个js函数，loader的执行顺序是从右往左，接收文件，处理，然后返回

plugin 传入compiler，通过监听compiler实现，需要传出什么？？

plugin怎么实现监听整个打包过程？

​	compiler 和 compilelation 都是基于tapable实现的，发布订阅，异步使用 同步使用

同步钩子通过tab注册，通过call触发；异步钩子通过tap tapAsync tapPromise注册，通过call callAsync promise触发

## 热更新怎么实现的

​	HMR 和 WDS配和使用： WDS提供链接访问资源的方法，HMR 实现了热更新的功能，检测到文件变化，就可以更新

​    HMR server 服务端监听变化，通过ws将变化传给客服端(浏览器) HRM Runtime

## tree shaking 怎么实现

先标记 在删除

- `ES6`的模块引入是静态分析的，所以在编译时能正确判断到底加载了哪些模块
- 分析程序流，判断哪些变量未被使用、引用，进而删除此代码

 	不可到达的代码

​	 只读不写的变量

​    代码结果不会被用到

## webapck优化

分析原因：

​	体积分析： speed-measure-webapck-plugin

​	速度分析：webpack-bundle-analyzer

加快打包速度: 启用多进程打包 thread-loader  

预编译：提前将图片进行处理

利用二次缓存：例如：  terser-webpack-plugin 设置使用缓存


## 封装组件
	职责单一、入参出参检查、追求无副作用、避免参数太多、追求短小精悍、减少依赖
	这个组件可否（有必要）再分？
		组件划分的依据通常是 业务逻辑、功能，要考虑各组件之间的关系是否明确（如组件树方式管理组件间依赖关系，兄弟组件不可见），以及组件的可复用度。
		划分粒度的大小需要根据实际情况权衡，太小会提升维护成本，太大又不够灵活和高复用性。
		每一个组件都应该有其独特的划分目的的，有的是为了复用实现，有的是为了封装复杂度清晰业务实现。

	这个组件的依赖是否可再缩减？
		缩减组件依赖可以提高组件的可复用度，常用的方法是IoC（依赖注入），对外弱类型依赖。

	这个组件是否对其它组件造成侵入？
		一个组件的封装性不够，或者自身越界操作，就可能对自身之外造成了侵入，这种情况应该尽量避免，确保组件的生命周期能够对其影响进行有效的管理（如destroy后不留痕迹）。

		较常见的一种情况是：组件运行时对window对象添加resize监听事件以实现组件响应视窗尺寸变化事件，这种需求的更好替代方案是：组件提供刷新方法，由父组件实现调用（最终由根组件统一处理）。
		次优的方案是，当组件destroy前清理恢复。
		一个组件不应对其它兄弟组件造成直接影响。

	这个组件可否复用于其它类似场景中？
		需要考虑需要适用的不同场景，在组件接口设计时进行必要的兼容。

	这个组件当别人用时，会怎么想？
		接口设计符合规范和大众习惯，尽量让别人用起来简单易上手，易上手是指更符合直觉。

	假如业务需要不需要这个功能，是否方便清除？
		各组件之前以组合的关系互相配合，也是对功能需求的模块化抽象，当需求变化时可以将实现以模块粒度进行调整。