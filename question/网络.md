## http状态码

- 1xx 信息性状态码 websocket upgrade

- 2xx 成功状态码

  - 200 服务器已成功处理了请求
  - 204(没有响应体)
  - 206(范围请求 暂停继续下载)

- 3xx 重定向状态码

  - 301(永久) ：请求的页面已永久跳转到新的url
  - 302(临时) ：允许各种各样的重定向，一般情况下都会实现为到 `GET` 的重定向，但是不能确保 `POST` 会重定向为 `POST`
  - 303 只允许任意请求到 `GET` 的重定向
  - 304 未修改：自从上次请求后，请求的网页未修改过
  - 307：`307` 和 `302` 一样，除了不允许 `POST` 到 `GET` 的重定向

- 4xx 客户端错误状态码

  - 400 客户端参数错误
  - 401 没有登录
  - 403 登录了没权限 比如管理系统
  - 404 页面不存在
  - 405 禁用请求中指定的方法

- 5xx 服务端错误状态码

  - 500 服务器错误：服务器内部错误，无法完成请求
  - 502 错误网关：服务器作为网关或代理出现错误
  - 503 服务不可用：服务器目前无法使用
  - 504 网关超时：网关或代理服务器，未及时获取请求


100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输

206：一般用来做断点续传，或者是视频文件等大文件的加载

301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名

302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面

304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分

400：参数有误，请求无法被服务器识别

403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回

404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时

503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503

504：网关超时



  ## 三次握手 四次挥手

- 第一次握手成功让服务端知道了客户端具有发送能力
- 第二次握手成功让客户端知道了服务端具有接收和发送能力，但此时服务端并不知道客户端是否接收到了自己发送的消息
- 所以第三次握手就起到了这个作用。

## 浏览器缓存

### 强制缓存

​	expires: 其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。

​	cache-Control:是最重要的规则，主要用于控制网页缓存，主要取值为：

- public：所有内容都将被缓存（客户端和代理服务器都可缓存）
- private：所有内容只有客户端可以缓存，Cache-Control的默认取值
- no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
- no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
- max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

cache-Control 优先级大于 expires，cache-Control是一个相对值，expires是一个绝对值


### 协商缓存(需要与cache-control配合使用)

​	强制缓存失效，使用协商缓存，协商缓存生效返回304

​	last-modified / if-modified-since:  资源最后修改时间

​	etag / if-none-match: 文件的唯一标志

​	etag 优先级大于 last-modified，last-modified精确到秒级，一秒内的改动无法保证文件最新

### http 和 https
 http是超文本传输协议基于明文传输的，可以传输任何数据类型，具体取决于content-type，http是无连接即处理完请求，收到客户端回应后，就会断开连接，也是无状态的无法根据之前的状态处理本次请求。
 https是在http的基础上进行加密处理，通过SSL（secure sockets layer） + TSL（transport layer security）,SSL 主要通过
 https交换密钥是通过混合加密实现的。摘要算法主要是确保数据的完整性，没有被修改，摘要算法会将任意长度的数据压缩成固定长度、且独一无二的字符串。数字签名是为了确保消息是由发送方签名并发出来的，签名任何人都可以获取，但是只有用私钥对应的公钥才能解开。

 ### tcp 和 udp
 udp（user datapackage protocol）用户数据包协议
 tcp（transform control protocol） 传输控制协议
 udp只会加上包头，然后发送出去，不会做负载均衡、分包？ 发送顺序的处理、选择好的发送链路
 tcp可以做到负载均衡，tcp会创建资源池，如果出现堵塞，会将请求发到资源池内

 tcp适用于需要准确传递信息的场景，那些场景？
 upd只需要快速发送？ 类比发布订阅 与 观察者模式？

 ### iso七层模型

 ### DNS（Domain Names Stystem）

 ### CDN（content deliverty network）

 ### http1.0、http1.1 和 http2.0
  http1.0 与服务器只会保持短暂的连接，每次请求都需要建立一个tcp连接，完成请求后会断开连接。
  http1.1 默认支持长连接（connection: keep-alive），即可以在一个tcp连接上发送多个htpp请求，同时允许客户端不需要等待上一次请求返回就可以发送请求，但是服务端必须按顺序返回请求。同时增加更多的响应头，完善功能，例如引入缓存控制策略；增加了delete put options请求。
  http2.0 新增多路复用、二进制分帧、头部压缩和服务器推送。复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞。HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x的文本格式，解析起来更高效，将请求和响应数据分割为更小的帧，并且它们采用二进制编码，帧可以乱序发送，通过帧首部的流标识重新组装，这也是多路复用的基础。HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的请求，不需要发送首部。允许服务器将资源推送给客户端，适用于静态资源加载，将需要的静态资源提前发送过去，减少请求。


 ### get 和 post
  都是基于tcp链接，只是浏览器和服务器做了一些限制才会有一些区别

 ### http请求头
  协商缓存
  会话状态

 ### tcp四次握手三次挥手

 ### webScoket






